<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yusuf Ali Khan - Design v12 (Interactive Helix)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a0b2e; color: white; font-family: 'Quicksand', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        .ui-layer { position: relative; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="ui-layer min-h-screen flex items-center justify-end px-[10%]">
        <div class="text-right">
            <h1 class="text-6xl md:text-8xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-l from-pink-500 to-violet-500">
                The DNA of <br> Code.
            </h1>
            <p class="text-xl text-violet-200 mb-8 max-w-md ml-auto">
                Evolutionary Salesforce solutions that adapt and scale with your business needs.
            </p>
            <button class="pointer-events-auto bg-pink-500 hover:bg-pink-600 text-white px-8 py-3 rounded-full font-bold shadow-lg shadow-pink-500/50 transition transform hover:-translate-x-2">
                Discover More
            </button>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0b2e, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Helix
        const geometry = new THREE.BufferGeometry();
        const count = 200;
        const positions = [];
        const colors = [];

        for(let i = 0; i < count; i++) {
            const t = i * 0.1;
            const x = Math.sin(t) * 3;
            const y = (i - count/2) * 0.1;
            const z = Math.cos(t) * 3;
            
            positions.push(x, y, z);
            
            // Second strand
            positions.push(-x, y, -z);

            // Colors
            colors.push(1, 0.2, 0.5); // Pink
            colors.push(0.5, 0.2, 1); // Violet
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({ size: 0.2, vertexColors: true });
        const helix = new THREE.Points(geometry, material);
        scene.add(helix);

        // Connecting Lines
        const lineGeo = new THREE.BufferGeometry().setFromPoints(geometry.attributes.position.array);
        // This is simplified, usually requires line segments logic. 
        // Let's use TubGeomtry for strand instead for better look
        
        const curve = new THREE.CatmullRomCurve3([]);
        const curve2 = new THREE.CatmullRomCurve3([]);
        
        for(let i=0; i<500; i++) {
            const t = i * 0.1;
            curve.points.push(new THREE.Vector3(Math.sin(t)*3, (i-250)*0.1, Math.cos(t)*3));
            curve2.points.push(new THREE.Vector3(-Math.sin(t)*3, (i-250)*0.1, -Math.cos(t)*3));
        }
        
        const tube1 = new THREE.Mesh(new THREE.TubeGeometry(curve, 100, 0.2, 8, false), new THREE.MeshPhongMaterial({color: 0xff00ff}));
        const tube2 = new THREE.Mesh(new THREE.TubeGeometry(curve2, 100, 0.2, 8, false), new THREE.MeshPhongMaterial({color: 0xaa00ff}));
        
        const helixGroup = new THREE.Group();
        helixGroup.add(tube1);
        helixGroup.add(tube2);
        
        // Add rungs
        for(let i=0; i<100; i+=5) {
             const points = curve.getPoints(100);
             const points2 = curve2.getPoints(100);
             // Simple cylinders connecting strands
             // omitted for speed, sticking to tubes
        }
        
        scene.add(helixGroup);
        helixGroup.rotation.z = Math.PI / 4;

        // Lights
        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(10, 10, 10);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        camera.position.z = 15;
        camera.position.y = 0;

        const animate = function () {
            requestAnimationFrame(animate);
            helixGroup.rotation.y += 0.01;
            helixGroup.position.y = Math.sin(Date.now()*0.001) * 2;
            renderer.render(scene, camera);
        };
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
